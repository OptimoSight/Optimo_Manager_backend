<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Optimized AR Makeup Filter</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"></script>
  <style>
    /* CSS remains the same as before */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 10px;
      overflow-x: hidden;
      background: #f0f0f0;
    }

    .video-container {
      position: relative;
      width: 100%;
      max-width: 400px;
      margin: 0 auto;
      aspect-ratio: 4/3;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
    }

    video,
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    video {
      transform: scaleX(-1);
    }

    .makeup-selector {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
      margin: 15px 0;
      background: white;
      border-radius: 15px;
      padding: 5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .makeup-tab {
      padding: 8px 12px;
      text-align: center;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
      user-select: none;
      font-size: 12px;
    }

    .makeup-tab.active {
      background: #FF1493;
      color: white;
      transform: scale(1.02);
    }

    .makeup-tab:not(.active) {
      color: #666;
    }

    .makeup-tab:hover {
      background: #FFE4E1;
    }

    .preset-color {
      width: 32px;
      height: 32px;
      display: inline-block;
      cursor: pointer;
      border: 2px solid #ddd;
      margin: 2px;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: all 0.2s;
    }

    .preset-color.selected {
      border-color: #FF1493;
      transform: scale(1.1);
    }

    .controls {
      margin: 20px 0;
      text-align: center;
    }

    .control-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin: 8px 0;
    }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 15px;
      background: #FF1493;
      color: white;
      font-size: 11px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: all 0.2s;
      min-height: 35px;
    }

    button:hover {
      background: #DC143C;
      transform: translateY(-1px);
    }

    button.inactive {
      background: #ccc;
    }

    button.applied {
      background: #28a745;
    }

    #status {
      text-align: center;
      padding: 15px;
      background: white;
      border-radius: 8px;
      margin: 10px 0;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-size: 14px;
    }

    .color-section {
      text-align: center;
      padding: 10px;
      background: white;
      border-radius: 8px;
      margin: 8px 0;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .color-section h3 {
      margin: 0 0 8px 0;
      color: #333;
      font-size: 14px;
    }

    h2 {
      text-align: center;
      color: #FF1493;
      margin-bottom: 20px;
    }

    .hidden {
      display: none;
    }

    .makeup-status {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin: 10px 0;
    }

    .status-item {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 4px 6px;
      background: white;
      border-radius: 12px;
      font-size: 10px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ccc;
    }

    .status-dot.active {
      background: #28a745;
    }
  </style>
</head>

<body>
  <h2>üíÑ Optimized AR Makeup Filter</h2>

  <div class="video-container">
    <video id="webcam" autoplay playsinline muted></video>
    <canvas id="output"></canvas>
  </div>

  <!-- Makeup Mode Selector -->
  <div class="makeup-selector">
    <div class="makeup-tab active" data-mode="lipstick">üíã Lipstick</div>
    <div class="makeup-tab" data-mode="blush">üå∏ Blush</div>
    <div class="makeup-tab" data-mode="eyeshadow">üëÅÔ∏è Eyes</div>
    <div class="makeup-tab" data-mode="eyeliner">‚úèÔ∏è Liner</div>
    <div class="makeup-tab" data-mode="foundation">üé≠ Base</div>
    <div class="makeup-tab" data-mode="contour">üåü Contour</div>
    <div class="makeup-tab" data-mode="concealer">‚≠ê Cover</div>
  </div>

  <!-- Makeup Status -->
  <div class="makeup-status">
    <div class="status-item">
      <div class="status-dot" id="lipstick-dot"></div>
      <span>Lips</span>
    </div>
    <div class="status-item">
      <div class="status-dot" id="blush-dot"></div>
      <span>Blush</span>
    </div>
    <div class="status-item">
      <div class="status-dot" id="eyeshadow-dot"></div>
      <span>Eyes</span>
    </div>
    <div class="status-item">
      <div class="status-dot" id="eyeliner-dot"></div>
      <span>Liner</span>
    </div>
  </div>
  <div class="makeup-status">
    <div class="status-item">
      <div class="status-dot" id="foundation-dot"></div>
      <span>Base</span>
    </div>
    <div class="status-item">
      <div class="status-dot" id="contour-dot"></div>
      <span>Contour</span>
    </div>
    <div class="status-item">
      <div class="status-dot" id="concealer-dot"></div>
      <span>Cover</span>
    </div>
    <div class="status-item">
      <div class="status-dot"></div>
      <span></span>
    </div>
  </div>

  <!-- Lipstick Colors -->
  <div class="color-section" id="lipstick-colors">
    <h3>üíã Lipstick Colors</h3>
    <div class="preset-color selected" style="background:#FF0000" data-color="#FF0000" title="Classic Red"></div>
    <div class="preset-color" style="background:#DC143C" data-color="#DC143C" title="Crimson"></div>
    <div class="preset-color" style="background:#FF1493" data-color="#FF1493" title="Deep Pink"></div>
    <div class="preset-color" style="background:#FF69B4" data-color="#FF69B4" title="Hot Pink"></div>
    <div class="preset-color" style="background:#C71585" data-color="#C71585" title="Medium Violet Red"></div>
    <div class="preset-color" style="background:#8B0000" data-color="#8B0000" title="Dark Red"></div>
  </div>

  <!-- Blush Colors -->
  <div class="color-section hidden" id="blush-colors">
    <h3>üå∏ Blush Colors</h3>
    <div class="preset-color selected" style="background:#FFB6C1" data-color="#FFB6C1" title="Light Pink"></div>
    <div class="preset-color" style="background:#FFC0CB" data-color="#FFC0CB" title="Pink"></div>
    <div class="preset-color" style="background:#FF91A4" data-color="#FF91A4" title="Rose"></div>
    <div class="preset-color" style="background:#FF7F7F" data-color="#FF7F7F" title="Coral"></div>
    <div class="preset-color" style="background:#CD5C5C" data-color="#CD5C5C" title="Indian Red"></div>
    <div class="preset-color" style="background:#F08080" data-color="#F08080" title="Light Coral"></div>
  </div>

  <!-- Eyeshadow Colors -->
  <div class="color-section hidden" id="eyeshadow-colors">
    <h3>üëÅÔ∏è Eyeshadow Gradient</h3>
    <div class="preset-color selected" style="background:linear-gradient(45deg, #736e73, #dbd7bf)" data-color1="#736e73"
      data-color2="#dbd7bf" title="Smokey"></div>
    <div class="preset-color" style="background:linear-gradient(45deg, #691767, #c19ac7)" data-color1="#691767"
      data-color2="#c19ac7" title="Purple"></div>
    <div class="preset-color" style="background:linear-gradient(45deg, #8B4513, #daa520)" data-color1="#8B4513"
      data-color2="#daa520" title="Bronze"></div>
    <div class="preset-color" style="background:linear-gradient(45deg, #4169E1, #87ceeb)" data-color1="#4169E1"
      data-color2="#87ceeb" title="Blue"></div>
    <div class="preset-color" style="background:linear-gradient(45deg, #228B22, #90ee90)" data-color1="#228B22"
      data-color2="#90ee90" title="Green"></div>
    <div class="preset-color" style="background:linear-gradient(45deg, #FFD700, #fff8dc)" data-color1="#FFD700"
      data-color2="#fff8dc" title="Gold"></div>
  </div>

  <!-- Eyeliner Colors -->
  <div class="color-section hidden" id="eyeliner-colors">
    <h3>‚úèÔ∏è Eyeliner Colors</h3>
    <div class="preset-color selected" style="background:#000000" data-color="#000000" title="Black"></div>
    <div class="preset-color" style="background:#4B0082" data-color="#4B0082" title="Indigo"></div>
    <div class="preset-color" style="background:#8B4513" data-color="#8B4513" title="Brown"></div>
    <div class="preset-color" style="background:#006400" data-color="#006400" title="Dark Green"></div>
    <div class="preset-color" style="background:#8B0000" data-color="#8B0000" title="Dark Red"></div>
    <div class="preset-color" style="background:#483D8B" data-color="#483D8B" title="Dark Slate Blue"></div>
  </div>

  <!-- Foundation Colors -->
  <div class="color-section hidden" id="foundation-colors">
    <h3>üé≠ Foundation Colors</h3>
    <div class="preset-color selected" style="background:#FDBCB4" data-color="#FDBCB4" title="Light"></div>
    <div class="preset-color" style="background:#EDB98A" data-color="#EDB98A" title="Medium Light"></div>
    <div class="preset-color" style="background:#D08B5B" data-color="#D08B5B" title="Medium"></div>
    <div class="preset-color" style="background:#AE6938" data-color="#AE6938" title="Medium Deep"></div>
    <div class="preset-color" style="background:#8D5524" data-color="#8D5524" title="Deep"></div>
    <div class="preset-color" style="background:#6B4226" data-color="#6B4226" title="Dark"></div>
  </div>

  <!-- Contour Colors -->
  <div class="color-section hidden" id="contour-colors">
    <h3>üåü Contour Colors</h3>
    <div class="preset-color selected" style="background:#D2B48C" data-color="#D2B48C" title="Light Tan"></div>
    <div class="preset-color" style="background:#CD853F" data-color="#CD853F" title="Peru"></div>
    <div class="preset-color" style="background:#A0522D" data-color="#A0522D" title="Sienna"></div>
    <div class="preset-color" style="background:#8B7355" data-color="#8B7355" title="Gray Brown"></div>
    <div class="preset-color" style="background:#696969" data-color="#696969" title="Dim Gray"></div>
    <div class="preset-color" style="background:#8B7D6B" data-color="#8B7D6B" title="Light Gray"></div>
  </div>

  <!-- Concealer Colors -->
  <div class="color-section hidden" id="concealer-colors">
    <h3>‚≠ê Concealer Colors</h3>
    <div class="preset-color selected" style="background:#F2C9C0" data-color="#F2C9C0" title="Light"></div>
    <div class="preset-color" style="background:#E8B5A2" data-color="#E8B5A2" title="Medium Light"></div>
    <div class="preset-color" style="background:#D4A085" data-color="#D4A085" title="Medium"></div>
    <div class="preset-color" style="background:#C08B68" data-color="#C08B68" title="Medium Deep"></div>
    <div class="preset-color" style="background:#AC764A" data-color="#AC764A" title="Deep"></div>
    <div class="preset-color" style="background:#98612D" data-color="#98612D" title="Dark"></div>
  </div>

  <div class="controls">
    <div class="control-row">
      <button id="lipstickToggle">Lips</button>
      <button id="blushToggle">Blush</button>
      <button id="eyeshadowToggle">Eyes</button>
    </div>
    <div class="control-row">
      <button id="eyelinerToggle">Liner</button>
      <button id="foundationToggle">Base</button>
      <button id="contourToggle">Contour</button>
    </div>
    <div class="control-row">
      <button id="concealerToggle">Cover</button>
      <button id="removeAll" style="background:#dc3545; grid-column: span 2;">Remove All</button>
    </div>
  </div>

  <div id="status">Loading MediaPipe...</div>

  <script type="module">
    import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const video = document.getElementById('webcam');
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');

    let faceLandmarker = null;
    let currentMode = 'lipstick';
    let latestResults = null;
    let runningMode = "VIDEO";
    let isProcessing = false;
    let frameCount = 0;
    let lastFrameTime = 0;
    const TARGET_FPS = 30;
    const FRAME_TIME = 1000 / TARGET_FPS;

    // All makeup parameters as constants
    const LIP_OPACITY = 0.4;
    const LIP_GLOSS = 0.1;
    const LIP_SHIMMER = 0.01;
    const LIP_BLUR = 3;

    const BLUSH_OPACITY = 0.6;
    const BLUSH_BLUR = 8;
    const BLUSH_FEATHER = 0.6;
    const BLUSH_RADIUS = 1.2;

    const EYESHADOW_OPACITY = 0.5;
    const EYESHADOW_BLUR = 4;

    const FOUNDATION_OPACITY = 0.4;
    const FOUNDATION_BLUR = 2;

    const CONTOUR_OPACITY = 1.5;
    const CONTOUR_BLUR = 15;

    const CONCEALER_OPACITY = 2.0;
    const CONCEALER_BLUR = 20;

    const EYELINER_OPACITY = 0.9;
    const EYELINER_THICKNESS = 2.8;

    // Makeup state
    const makeupState = {
      lipstick: {
        enabled: false,
        color: '#FF0000',
        opacity: LIP_OPACITY,
        gloss: LIP_GLOSS,
        shimmer: LIP_SHIMMER,
        blur: LIP_BLUR
      },
      blush: {
        enabled: false,
        color: '#FFB6C1',
        radius: BLUSH_RADIUS,
        opacity: BLUSH_OPACITY,
        blur: BLUSH_BLUR,
        feather: BLUSH_FEATHER
      },
      eyeshadow: {
        enabled: false,
        color1: '#736e73',
        color2: '#dbd7bf',
        opacity: EYESHADOW_OPACITY,
        blur: EYESHADOW_BLUR
      },
      eyeliner: {
        enabled: false,
        color: '#000000',
        opacity: EYELINER_OPACITY,
        thickness: EYELINER_THICKNESS
      },
      foundation: {
        enabled: false,
        color: '#FDBCB4',
        opacity: FOUNDATION_OPACITY,
        blur: FOUNDATION_BLUR
      },
      contour: {
        enabled: false,
        color: '#D2B48C',
        opacity: CONTOUR_OPACITY,
        blur: CONTOUR_BLUR
      },
      concealer: {
        enabled: false,
        color: '#F2C9C0',
        opacity: CONCEALER_OPACITY,
        blur: CONCEALER_BLUR
      }
    };

    // Landmark indices
    const LIPS_OUTER = [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146];
    const LIPS_INNER = [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95];
    const BLUSH_PTS = [50, 205, 280, 425];
    const FACE_OVAL = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];

    // Eye landmarks
    const LEFT_EYE = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
    const RIGHT_EYE = [362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382];
    const LEFT_EYE_UPPER = [56, 222, 223, 224, 225, 156, 124, 130, 113, 30, 29, 27, 28, 56];
    const LEFT_EYE_LOWER = [56, 28, 27, 29, 30, 113, 130, 246, 161, 160, 159, 158, 157, 173, 56];
    const RIGHT_EYE_UPPER = [286, 442, 443, 444, 445, 383, 353, 359, 342, 260, 259, 257, 258, 286];
    const RIGHT_EYE_LOWER = [286, 258, 257, 259, 260, 342, 359, 466, 388, 387, 386, 385, 384, 398, 286];

    // Contour landmarks - Updated with new checkpoints
    const LEFT_CHEEKBONES_CONTOUR = [234, 147, 207];
    const RIGHT_CHEEKBONES_CONTOUR = [454, 376, 427];
    const NOSE_LEFT_CONTOUR = [45, 51, 3, 196, 122];
    const NOSE_RIGHT_CONTOUR = [275, 281, 248, 419, 351];
    const LEFT_CHEEKBONES_BORDER_CONTOUR = [116, 127, 119, 165, 57, 127];
    const RIGHT_CHEEKBONES_BORDER_CONTOUR = [345, 356, 348, 391, 287, 356];

    // Concealer landmarks - Updated with new checkpoints
    const LEFT_EYE_CONCEALER = [190, 233, 47, 142, 205, 50, 143, 190];
    const RIGHT_EYE_CONCEALER = [414, 453, 277, 371, 425, 280, 372, 414];

    let outerHistory = [], innerHistory = [], blushHistory = [];
    const MAX_HISTORY = 3;

    // Pre-allocate canvas objects to avoid creating them every frame
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    const blurCanvas = document.createElement('canvas');
    const blurCtx = blurCanvas.getContext('2d');

    // Initialize MediaPipe
    async function initializeMediaPipe() {
      document.getElementById('status').textContent = 'Loading MediaPipe Face Landmarker...';

      try {
        const filesetResolver = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );

        faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
          baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
            delegate: "GPU"
          },
          outputFaceBlendshapes: false,
          outputFacialTransformationMatrixes: false,
          runningMode: runningMode,
          numFaces: 1
        });

        console.log('‚úÖ MediaPipe Face Landmarker loaded successfully');
        document.getElementById('status').textContent = 'MediaPipe loaded! Starting camera...';
        return true;
      } catch (error) {
        console.error('‚ùå MediaPipe loading error:', error);
        document.getElementById('status').textContent = 'Error loading MediaPipe: ' + error.message;
        return false;
      }
    }

    // Setup webcam
    async function setupWebcam() {
      try {
        console.log('üé• Requesting camera access...');
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'user',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });

        video.srcObject = stream;

        return new Promise(resolve => {
          video.onloadedmetadata = () => {
            video.play().then(() => {
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              tempCanvas.width = video.videoWidth;
              tempCanvas.height = video.videoHeight;
              blurCanvas.width = video.videoWidth;
              blurCanvas.height = video.videoHeight;

              console.log(`üìê Canvas size: ${canvas.width}x${canvas.height}`);
              document.getElementById('status').textContent = 'Camera ready! Point your face at the camera';
              resolve(video);
            });
          };
        });
      } catch (error) {
        console.error('‚ùå Camera error:', error);
        document.getElementById('status').textContent = 'Camera access denied';
      }
    }

    // Utility functions
    function smoothPoints(landmarks, indices, historyArray) {
      if (!landmarks || landmarks.length < Math.max(...indices)) {
        return [];
      }

      const points = indices.map(i => ({
        x: landmarks[i].x * canvas.width,
        y: landmarks[i].y * canvas.height
      }));

      historyArray.push(points);
      if (historyArray.length > MAX_HISTORY) {
        historyArray.shift();
      }

      return points.map((_, idx) => {
        let sumX = 0, sumY = 0;
        historyArray.forEach(frame => {
          sumX += frame[idx].x;
          sumY += frame[idx].y;
        });
        return {
          x: sumX / historyArray.length,
          y: sumY / historyArray.length
        };
      });
    }

    function euclideanDistance(p1, p2) {
      return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    function getLandmarkPoints(landmarks, indices) {
      if (!landmarks || landmarks.length < Math.max(...indices)) {
        return [];
      }
      return indices.map(i => ({
        x: canvas.width - landmarks[i].x * canvas.width,
        y: landmarks[i].y * canvas.height
      }));
    }

    // Create gradient for smooth blending
    function createSmoothGradient(ctx, centerX, centerY, radius, color, opacity) {
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, radius
      );
      const rgb = hexToRgb(color);
      gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`);
      gradient.addColorStop(0.7, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity * 0.3})`);
      gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
      return gradient;
    }

    // Optimized blur function that reuses canvases
    function applyBlur(sourceCtx, blurAmount) {
      blurCtx.clearRect(0, 0, blurCanvas.width, blurCanvas.height);
      blurCtx.filter = `blur(${blurAmount}px)`;
      blurCtx.drawImage(sourceCtx.canvas, 0, 0);
      blurCtx.filter = 'none';
      return blurCtx.getImageData(0, 0, blurCanvas.width, blurCanvas.height);
    }

    // Draw foundation effect
    function drawFoundation() {
      if (!latestResults || !latestResults.faceLandmarks || latestResults.faceLandmarks.length === 0) {
        return;
      }

      const landmarks = latestResults.faceLandmarks[0];
      const facePoints = getLandmarkPoints(landmarks, FACE_OVAL);

      if (facePoints.length === 0) return;

      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.beginPath();
      facePoints.forEach((point, i) => {
        if (i === 0) {
          tempCtx.moveTo(point.x, point.y);
        } else {
          tempCtx.lineTo(point.x, point.y);
        }
      });
      tempCtx.closePath();

      tempCtx.globalAlpha = makeupState.foundation.opacity;
      tempCtx.fillStyle = makeupState.foundation.color;
      tempCtx.fill();

      const blurredImageData = applyBlur(tempCtx, makeupState.foundation.blur);
      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.putImageData(blurredImageData, 0, 0);

      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.7;
      ctx.drawImage(tempCanvas, 0, 0);
      ctx.restore();
    }

    // Draw gradient eyeshadow
    function drawEyeshadow() {
      if (!latestResults || !latestResults.faceLandmarks || latestResults.faceLandmarks.length === 0) {
        return;
      }

      const landmarks = latestResults.faceLandmarks[0];

      const leftUpperPoints = getLandmarkPoints(landmarks, LEFT_EYE_UPPER);
      const leftLowerPoints = getLandmarkPoints(landmarks, LEFT_EYE_LOWER);
      const rightUpperPoints = getLandmarkPoints(landmarks, RIGHT_EYE_UPPER);
      const rightLowerPoints = getLandmarkPoints(landmarks, RIGHT_EYE_LOWER);

      if (leftUpperPoints.length === 0 || rightUpperPoints.length === 0) return;

      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

      // Draw eyeshadow with gradient
      [leftUpperPoints, leftLowerPoints, rightUpperPoints, rightLowerPoints].forEach((points, index) => {
        if (points.length === 0) return;

        // Calculate center and bounds for gradient
        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const minY = Math.min(...points.map(p => p.y));
        const maxY = Math.max(...points.map(p => p.y));
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // Create gradient
        const gradient = tempCtx.createRadialGradient(
          centerX, centerY, 0,
          centerX, centerY, Math.max(maxX - minX, maxY - minY) / 2
        );
        gradient.addColorStop(0, makeupState.eyeshadow.color1);
        gradient.addColorStop(1, makeupState.eyeshadow.color2);

        tempCtx.beginPath();
        points.forEach((point, i) => {
          if (i === 0) {
            tempCtx.moveTo(point.x, point.y);
          } else {
            tempCtx.lineTo(point.x, point.y);
          }
        });
        tempCtx.closePath();

        tempCtx.globalAlpha = 0.5;
        tempCtx.fillStyle = gradient;
        tempCtx.fill();
      });

      const blurredImageData = applyBlur(tempCtx, 4);
      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.putImageData(blurredImageData, 0, 0);

      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.8;
      ctx.drawImage(tempCanvas, 0, 0);
      ctx.restore();
    }

    // Eyeliner with bold winged style
    function drawEyeliner() {
      if (!latestResults || !latestResults.faceLandmarks || latestResults.faceLandmarks.length === 0) return;

      const landmarks = latestResults.faceLandmarks[0];

      ctx.save();
      ctx.strokeStyle = makeupState.eyeliner.color;
      ctx.fillStyle = makeupState.eyeliner.color;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.globalAlpha = makeupState.eyeliner.opacity;

      function getXY(idx) {
        return {
          x: canvas.width - landmarks[idx].x * canvas.width,
          y: landmarks[idx].y * canvas.height,
        };
      }

      function euclideanDistance(p1, p2) {
        return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
      }

      function drawEyeLinerPath(indices, wingUpwardDir) {
        const lashPoints = indices.map(i => getXY(i));
        const inner = lashPoints[0];
        const outer = lashPoints[lashPoints.length - 1];

        // --- Inner taper (slight) ---
        const nextPoint = lashPoints[1];
        const innerOffset = {
          x: inner.x + (nextPoint.x - inner.x) * 0.3,
          y: inner.y + (nextPoint.y - inner.y) * 0.3,
        };

        // --- Draw lash-hugging line ---
        ctx.lineWidth = makeupState.eyeliner.thickness || 1.0; // thinner overall
        ctx.beginPath();
        ctx.moveTo(innerOffset.x, innerOffset.y);
        for (let i = 1; i < lashPoints.length; i++) {
          ctx.lineTo(lashPoints[i].x, lashPoints[i].y);
        }
        ctx.stroke();

        // --- Wing ---
        const lastPoint = lashPoints[lashPoints.length - 1];
        const prevPoint = lashPoints[lashPoints.length - 2];

        // Tangent along eyelid
        const tangentX = lastPoint.x - prevPoint.x;
        const tangentY = lastPoint.y - prevPoint.y;

        // Slightly upward angle
        const wingAngle = Math.atan2(tangentY, tangentX) - wingUpwardDir * Math.PI / 4; // smaller angle for upward

        const eyeLength = euclideanDistance(inner, outer);
        const wingLength = eyeLength * 0.34; // shorter wing

        // Wing tip
        const wingTip = {
          x: lastPoint.x + Math.cos(wingAngle) * wingLength,
          y: lastPoint.y + Math.sin(wingAngle) * wingLength * 0.6,
        };

        // Control point for smooth curve
        const controlPoint = {
          x: lastPoint.x + (wingTip.x - lastPoint.x) * 0.5,
          y: lastPoint.y + (wingTip.y - lastPoint.y) * 0.2,
        };

        // Taper line width from lash to tip
        const taperSteps = 8;
        for (let i = 0; i < taperSteps; i++) {
          const t = i / taperSteps;
          const x = lastPoint.x + (controlPoint.x - lastPoint.x) * t + (wingTip.x - controlPoint.x) * t * t;
          const y = lastPoint.y + (controlPoint.y - lastPoint.y) * t + (wingTip.y - controlPoint.y) * t * t;
          ctx.lineWidth = makeupState.eyeliner.thickness * (1 - t * 0.9); // taper to very thin
          if (i === 0) ctx.beginPath(), ctx.moveTo(lastPoint.x, lastPoint.y);
          ctx.lineTo(x, y);
          ctx.stroke();
        }
      }

      // Left eye
      drawEyeLinerPath([133, 173, 157, 158, 159, 160, 161, 246, 33], +1);

      // Right eye
      drawEyeLinerPath([362, 398, 384, 385, 386, 387, 388, 466, 263], -1);

      ctx.restore();
    }

    // Improved contour with smooth edge blending
    function drawContour() {
      if (!latestResults || !latestResults.faceLandmarks || latestResults.faceLandmarks.length === 0) {
        return;
      }

      const landmarks = latestResults.faceLandmarks[0];
      const leftCheekPoints = getLandmarkPoints(landmarks, LEFT_CHEEKBONES_CONTOUR);
      const rightCheekPoints = getLandmarkPoints(landmarks, RIGHT_CHEEKBONES_CONTOUR);
      const noseLeftPoints = getLandmarkPoints(landmarks, NOSE_LEFT_CONTOUR);
      const noseRightPoints = getLandmarkPoints(landmarks, NOSE_RIGHT_CONTOUR);

      if (leftCheekPoints.length === 0 || rightCheekPoints.length === 0) return;

      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

      // Draw smooth contour areas instead of lines
      function drawSmoothContourArea(points, intensity = 0.3) {
        if (points.length < 3) return;

        // Calculate center point
        const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

        // Calculate average radius
        const avgRadius = points.reduce((sum, p) => {
          return sum + Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2);
        }, 0) / points.length;

        // Create smooth gradient
        const gradient = createSmoothGradient(
          tempCtx, centerX, centerY, avgRadius * 1.5,
          makeupState.contour.color, intensity
        );

        tempCtx.fillStyle = gradient;
        tempCtx.beginPath();
        tempCtx.arc(centerX, centerY, avgRadius * 1.5, 0, Math.PI * 2);
        tempCtx.fill();
      }

      // Apply contour to cheekbones
      drawSmoothContourArea(leftCheekPoints, 0.4);
      drawSmoothContourArea(rightCheekPoints, 0.4);

      // Apply subtle nose contour
      if (noseLeftPoints.length > 0) {
        drawSmoothContourArea(noseLeftPoints, 0.25);
      }
      if (noseRightPoints.length > 0) {
        drawSmoothContourArea(noseRightPoints, 0.25);
      }

      // Apply heavy blur for natural blending
      const blurredImageData = applyBlur(tempCtx, makeupState.contour.blur);
      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.putImageData(blurredImageData, 0, 0);

      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = makeupState.contour.opacity;
      ctx.drawImage(tempCanvas, 0, 0);
      ctx.restore();
    }

    // Improved concealer with natural blending
    function drawConcealer() {
      if (!latestResults || !latestResults.faceLandmarks || latestResults.faceLandmarks.length === 0) {
        return;
      }

      const landmarks = latestResults.faceLandmarks[0];
      const leftEyeArea = getLandmarkPoints(landmarks, LEFT_EYE_CONCEALER);
      const rightEyeArea = getLandmarkPoints(landmarks, RIGHT_EYE_CONCEALER);

      if (leftEyeArea.length === 0 || rightEyeArea.length === 0) return;

      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

      function drawSmoothConcealerArea(points, intensity = 0.6) {
        if (points.length < 3) return;

        // Calculate center and average radius
        const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
        const avgRadius = points.reduce((sum, p) => {
          return sum + Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2);
        }, 0) / points.length;

        // Create smooth gradient for natural blending
        const gradient = createSmoothGradient(
          tempCtx, centerX, centerY, avgRadius * 1.8,
          makeupState.concealer.color, intensity
        );

        tempCtx.fillStyle = gradient;
        tempCtx.beginPath();
        tempCtx.arc(centerX, centerY, avgRadius * 1.8, 0, Math.PI * 2);
        tempCtx.fill();
      }

      // Apply concealer to under-eye areas
      drawSmoothConcealerArea(leftEyeArea, 0.5);
      drawSmoothConcealerArea(rightEyeArea, 0.5);

      // Apply extra heavy blur for seamless blending
      const blurredImageData = applyBlur(tempCtx, makeupState.concealer.blur);
      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.putImageData(blurredImageData, 0, 0);

      ctx.save();
      ctx.globalCompositeOperation = 'overlay';
      ctx.globalAlpha = makeupState.concealer.opacity;
      ctx.drawImage(tempCanvas, 0, 0);
      ctx.restore();
    }

    // Draw lipstick effect
    function drawLipstick() {
      if (!latestResults || !latestResults.faceLandmarks || latestResults.faceLandmarks.length === 0) {
        return;
      }

      const landmarks = latestResults.faceLandmarks[0];

      const outerPoints = smoothPoints(landmarks, LIPS_OUTER, outerHistory);
      const innerPoints = smoothPoints(landmarks, LIPS_INNER, innerHistory);

      if (outerPoints.length === 0 || innerPoints.length === 0) {
        return;
      }

      const outer = outerPoints.map(p => ({ x: canvas.width - p.x, y: p.y }));
      const inner = innerPoints.map(p => ({ x: canvas.width - p.x, y: p.y }));

      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.beginPath();
      outer.forEach((point, i) => {
        if (i === 0) {
          tempCtx.moveTo(point.x, point.y);
        } else {
          tempCtx.lineTo(point.x, point.y);
        }
      });
      tempCtx.closePath();

      inner.forEach((point, i) => {
        if (i === 0) {
          tempCtx.moveTo(point.x, point.y);
        } else {
          tempCtx.lineTo(point.x, point.y);
        }
      });
      tempCtx.closePath();

      tempCtx.globalAlpha = makeupState.lipstick.opacity;
      tempCtx.fillStyle = makeupState.lipstick.color;
      tempCtx.fill('evenodd');

      const blurredImageData = applyBlur(tempCtx, makeupState.lipstick.blur);
      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.putImageData(blurredImageData, 0, 0);

      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.drawImage(tempCanvas, 0, 0);
      ctx.restore();

      // Add gloss
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = makeupState.lipstick.gloss;

      const centerX = outer.reduce((sum, p) => sum + p.x, 0) / outer.length;
      const centerY = outer.reduce((sum, p) => sum + p.y, 0) / outer.length;

      const glossGradient = ctx.createRadialGradient(
        centerX, centerY - 8, 0,
        centerX, centerY - 8, 25
      );
      glossGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
      glossGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

      ctx.fillStyle = glossGradient;

      ctx.beginPath();
      outer.forEach((point, i) => {
        if (i === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      ctx.closePath();
      inner.forEach((point, i) => {
        if (i === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      ctx.closePath();

      ctx.fill('evenodd');
      ctx.restore();
    }

    // Draw blush effect with adjustable radius
    function drawBlush() {
      if (!latestResults || !latestResults.faceLandmarks || latestResults.faceLandmarks.length === 0) {
        return;
      }

      const landmarks = latestResults.faceLandmarks[0];
      const blushPoints = smoothPoints(landmarks, BLUSH_PTS, blushHistory);

      if (blushPoints.length < 4) {
        return;
      }

      const mirroredPoints = blushPoints.map(p => ({ x: canvas.width - p.x, y: p.y }));

      const leftRadius = euclideanDistance(mirroredPoints[0], mirroredPoints[1]) * makeupState.blush.radius;
      const rightRadius = euclideanDistance(mirroredPoints[2], mirroredPoints[3]) * makeupState.blush.radius;

      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      const blushRgb = hexToRgb(makeupState.blush.color);

      // Draw left cheek blush
      const leftGradient = tempCtx.createRadialGradient(
        mirroredPoints[0].x, mirroredPoints[0].y, 0,
        mirroredPoints[0].x, mirroredPoints[0].y, leftRadius
      );
      leftGradient.addColorStop(0, `rgba(${blushRgb.r}, ${blushRgb.g}, ${blushRgb.b}, 0.6)`);
      leftGradient.addColorStop(0.6, `rgba(${blushRgb.r}, ${blushRgb.g}, ${blushRgb.b}, 0.3)`);
      leftGradient.addColorStop(1, `rgba(${blushRgb.r}, ${blushRgb.g}, ${blushRgb.b}, 0)`);

      tempCtx.fillStyle = leftGradient;
      tempCtx.beginPath();
      tempCtx.arc(mirroredPoints[0].x, mirroredPoints[0].y, leftRadius, 0, Math.PI * 2);
      tempCtx.fill();

      // Draw right cheek blush
      const rightGradient = tempCtx.createRadialGradient(
        mirroredPoints[2].x, mirroredPoints[2].y, 0,
        mirroredPoints[2].x, mirroredPoints[2].y, rightRadius
      );
      rightGradient.addColorStop(0, `rgba(${blushRgb.r}, ${blushRgb.g}, ${blushRgb.b}, 0.6)`);
      rightGradient.addColorStop(0.6, `rgba(${blushRgb.r}, ${blushRgb.g}, ${blushRgb.b}, 0.3)`);
      rightGradient.addColorStop(1, `rgba(${blushRgb.r}, ${blushRgb.g}, ${blushRgb.b}, 0)`);

      tempCtx.fillStyle = rightGradient;
      tempCtx.beginPath();
      tempCtx.arc(mirroredPoints[2].x, mirroredPoints[2].y, rightRadius, 0, Math.PI * 2);
      tempCtx.fill();

      const blurredImageData = applyBlur(tempCtx, makeupState.blush.blur);
      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.putImageData(blurredImageData, 0, 0);

      ctx.save();
      ctx.globalCompositeOperation = 'overlay';
      ctx.globalAlpha = makeupState.blush.opacity;
      ctx.drawImage(tempCanvas, 0, 0);
      ctx.restore();
    }

    // Main drawing function
    function drawMakeup() {
      // Skip frame if we're still processing the previous one
      const now = performance.now();
      if (isProcessing || (now - lastFrameTime) < FRAME_TIME) {
        requestAnimationFrame(drawMakeup);
        return;
      }
      
      isProcessing = true;
      lastFrameTime = now;
      frameCount++;

      // Clear and draw video
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.scale(-1, 1);
      ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
      ctx.restore();

      if (!latestResults) {
        isProcessing = false;
        requestAnimationFrame(drawMakeup);
        return;
      }

      // Apply all enabled makeup in proper order
      if (makeupState.foundation.enabled) {
        drawFoundation();
      }

      if (makeupState.concealer.enabled) {
        drawConcealer();
      }

      if (makeupState.contour.enabled) {
        drawContour();
      }

      if (makeupState.eyeshadow.enabled) {
        drawEyeshadow();
      }

      if (makeupState.eyeliner.enabled) {
        drawEyeliner();
      }

      if (makeupState.blush.enabled) {
        drawBlush();
      }

      if (makeupState.lipstick.enabled) {
        drawLipstick();
      }

      isProcessing = false;
      requestAnimationFrame(drawMakeup);
    }

    let lastVideoTime = -1;

    // Detection and render loop
    function predictWebcam() {
      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;

        try {
          const startTimeMs = performance.now();
          const results = faceLandmarker.detectForVideo(video, startTimeMs);

          if (results.faceLandmarks && results.faceLandmarks.length > 0) {
            latestResults = results;
            const appliedCount = Object.values(makeupState).filter(m => m.enabled).length;
            document.getElementById('status').textContent = `‚ú® Face detected! ${appliedCount} makeup effects applied`;
          } else {
            latestResults = null;
            document.getElementById('status').textContent = 'üë§ Looking for face... Make sure you\'re well-lit and centered';
          }
        } catch (error) {
          console.error('Detection error:', error);
        }
      }

      requestAnimationFrame(predictWebcam);
    }

    // Update status dots
    function updateStatusDots() {
      Object.keys(makeupState).forEach(type => {
        const dot = document.getElementById(`${type}-dot`);
        if (dot) {
          if (makeupState[type].enabled) {
            dot.classList.add('active');
          } else {
            dot.classList.remove('active');
          }
        }
      });
    }

    // Update button states
    function updateButtons() {
      Object.keys(makeupState).forEach(type => {
        const button = document.getElementById(`${type}Toggle`);
        if (button) {
          if (makeupState[type].enabled) {
            button.textContent = `‚úì ${type.charAt(0).toUpperCase() + type.slice(1)}`;
            button.classList.add('applied');
            button.classList.remove('inactive');
          } else {
            button.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            button.classList.remove('applied');
            button.classList.add('inactive');
          }
        }
      });
      updateStatusDots();
    }

    // UI Event handlers
    document.querySelectorAll('.makeup-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.makeup-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        currentMode = tab.dataset.mode;

        document.querySelectorAll('.color-section').forEach(section => {
          section.classList.add('hidden');
        });
        document.getElementById(`${currentMode}-colors`).classList.remove('hidden');
      });
    });

    // Individual makeup toggle buttons
    document.getElementById('lipstickToggle').addEventListener('click', () => {
      makeupState.lipstick.enabled = !makeupState.lipstick.enabled;
      updateButtons();
    });

    document.getElementById('blushToggle').addEventListener('click', () => {
      makeupState.blush.enabled = !makeupState.blush.enabled;
      updateButtons();
    });

    document.getElementById('eyeshadowToggle').addEventListener('click', () => {
      makeupState.eyeshadow.enabled = !makeupState.eyeshadow.enabled;
      updateButtons();
    });

    document.getElementById('eyelinerToggle').addEventListener('click', () => {
      makeupState.eyeliner.enabled = !makeupState.eyeliner.enabled;
      updateButtons();
    });

    document.getElementById('foundationToggle').addEventListener('click', () => {
      makeupState.foundation.enabled = !makeupState.foundation.enabled;
      updateButtons();
    });

    document.getElementById('contourToggle').addEventListener('click', () => {
      makeupState.contour.enabled = !makeupState.contour.enabled;
      updateButtons();
    });

    document.getElementById('concealerToggle').addEventListener('click', () => {
      makeupState.concealer.enabled = !makeupState.concealer.enabled;
      updateButtons();
    });

    // Remove all makeup
    document.getElementById('removeAll').addEventListener('click', () => {
      Object.keys(makeupState).forEach(type => {
        makeupState[type].enabled = false;
      });
      updateButtons();
    });

    // Color selection handlers
    function setupColorSelection(type) {
      document.getElementById(`${type}-colors`).addEventListener('click', (e) => {
        if (e.target.classList.contains('preset-color')) {
          if (type === 'eyeshadow') {
            makeupState[type].color1 = e.target.dataset.color1 || e.target.dataset.color;
            makeupState[type].color2 = e.target.dataset.color2 || e.target.dataset.color;
          } else {
            makeupState[type].color = e.target.dataset.color;
          }
          makeupState[type].enabled = true;

          document.querySelectorAll(`#${type}-colors .preset-color`).forEach(el => el.classList.remove('selected'));
          e.target.classList.add('selected');

          document.querySelectorAll('.makeup-tab').forEach(t => t.classList.remove('active'));
          document.querySelector(`[data-mode="${type}"]`).classList.add('active');

          document.querySelectorAll('.color-section').forEach(section => {
            section.classList.add('hidden');
          });
          document.getElementById(`${type}-colors`).classList.remove('hidden');

          currentMode = type;
          updateButtons();
        }
      });
    }

    // Setup color selection for all makeup types
    ['lipstick', 'blush', 'eyeshadow', 'eyeliner', 'foundation', 'contour', 'concealer'].forEach(setupColorSelection);

    // Initialize everything
    async function init() {
      const mediaPipeLoaded = await initializeMediaPipe();
      if (!mediaPipeLoaded) {
        return;
      }

      await setupWebcam();
      updateButtons();
      predictWebcam();
      drawMakeup();
    }

    // Start when ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>